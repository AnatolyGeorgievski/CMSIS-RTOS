/*
 * stribog.c
 *
 *  Created on: May 5, 2012
 *      Author: Oleksandr Kazymyrov
 *		Acknowledgments: Oleksii Shevchuk
 */
 
#if 0
// \see https://www.hse.ru/data/2013/08/01/1291252307/lebedev-hashes.pdf
const  uint8_t  pi[256] = {
/* pi  constant  */
};
const  uint64_t A[64] = {
/* A constant  */
};
uint64_t  mul_table [8][256];
void  precalc_mul_table ()
{
for(int i=0;i<8;++i)
for(int j=0;j <256;++j){
uint64_t t = 0;
uint8_t p = pi[j];
for(int k=0;k<8;++k)
if(p&(1<<k))
t ^= A[(i<<3)|k];
mul_table[i][j] = t;
}
}
void  lps(uint64_t* out ,const  uint8_t* in)
{
for(int i=0;i<8;++i){
uint64_t t = mul_table [0][in[i]];
for(int k=1;k<8;++k)
t ^=  mul_table[k][in[i+k*8]];
out[i] = t;
}
}

#endif

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <math.h>

#include "stribog_data.h"
#pragma GCC optimize("Os")
static void AddModulo512(const unsigned char *a,const unsigned char *b,unsigned char *c)
{
	int i = 0, t = 0;

	for(i=63;i>=0;i--)
	{
		t = a[i] + b[i] + (t >> 8);
		c[i] = t & 0xFF;
	}
}

static void AddXor512(const void *a,const void *b,void *c)
{
	int i = 0;
	const uint32_t *A=a, *B=b;
	uint32_t *C=c;

	for(i=0;i<16;i++)
	{
		C[i] = A[i] ^ B[i];
	}
}

static void S(unsigned char *state)
{
	int i = 0;

	for(i=0;i<64;i++)
	{
		state[i] = Sbox[state[i]];
	}
}
/* Преобразование L можно представить матричным умножением в поле 0x171

Algebraic Aspects of the Russian Hash Standard GOST R 34.11-2012
Oleksandr Kazymyrov, Valentyna Kazymyrova

M = {
71 05 09 B9 61 A2 27 0E
04 88 5B B2 E4 36 5F 65
5F CB AD 0F BA 2C 04 A5
E5 01 54 BA 0F 11 2A 76
D4 81 1C FA 39 5E 15 24
05 71 5E 66 17 1C D0 02
2D F1 E7 28 55 A0 4C 9A
0E 02 F6 8A 15 9D 39 71
};
L = B*A
Пояснение, как оно соотносится с с матрицей A
Колонка 1 матрицы M - это элемент A[0], для которого выполнен разворот порядка следования бит. 
8E=>71 20=>04 FA=>5F
Колонка 2 матрицы M - это элемент A[8],
. . .
Колонка 8 матрицы M - это элемент A[56],

От транспонивания вероятно можно избавиться
Умножение можно выполнить на аффинных преобразованиях или на умножении без переноса с редуцированием

На Neon есть умножение без переноса (Polynomial) 8x8 => 16*8
*/

static void L(unsigned char *state)
{
	unsigned long long v = 0;
	int i = 0, j = 0, k = 0;

	for(i=0;i<8;i++)
	{
		v=0;
		for(k=0;k<8;k++)
		{
			for(j=0;j<8;j++)
			{
				if ((state[i*8+k] & (1<<(7-j))) != 0)
					v ^= A[k*8+j];// v = REV8(K[i*8+k] (*) REV8(state[n]) mod 0x171)
			}
		}
		for(k=0;k<8;k++)
		{
			state[i*8+k] = (v & ((unsigned long long)0xFF << (7-k)*8)) >> (7-k)*8;
		}
	}
}

static void P(unsigned char *state)
{
	int i = 0;
	unsigned char t[64] = {};

	for(i=0;i<64;i++)
	{
		t[i] = state[Tau[i]];
	}

	memcpy(state,t,64);
}

static void KeySchedule(unsigned char *K,int i)
{
	AddXor512(K,C[i],K);

    S(K);// подстановка
    P(K);// транспонирование
    L(K);// линейная операция
}

static void E(unsigned char *K,const unsigned char *m, unsigned char *state)
{
	int i = 0;

	memcpy(K,K,64);

	AddXor512(m,K,state);

    for(i=0;i<12;i++)
    {
		AddXor512(K,C[i],K);

		S(K);// подстановка
		P(K);// транспонирование
		L(K);// линейная операция
		
        S(state);// подстановка
        P(state);// транспонирование
        L(state);
//        KeySchedule(K,i);
        AddXor512(state,K,state);
    }
}

static void g_N(const unsigned char *N,unsigned char *h,const unsigned char *m)
{
	unsigned char t[64], K[64];

	AddXor512(N,h,K);

    S(K);
    P(K);// транспонирование
    L(K);// линейная операция

    E(K,m,t);

    AddXor512(t,h,t);
    AddXor512(t,m,h);
}
void hash_X(unsigned char *IV,const unsigned char *message,unsigned long long length,unsigned char *out)
{
	unsigned char v512[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00
	};
	unsigned char v0[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};
	unsigned char Sigma[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};
	unsigned char N[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};
	unsigned char m[64], *hash = IV;
	unsigned long long len = length;

	// Stage 2
	while (len >= 512)
	{
		memcpy(m, message + len/8 - 63 - ( (len & 0x7) == 0 ), 64);

		g_N(N,hash,m);
		AddModulo512(N,v512,N);
		AddModulo512(Sigma,m,Sigma);
		len -= 512;
	}

	memset(m,0,64);
	memcpy(m + 63 - len/8 + ( (len & 0x7) == 0 ), message, len/8 + 1 - ( (len & 0x7) == 0 ));

	// Stage 3
	m[ 63 - len/8 ] |= (1 << (len & 0x7));

	g_N(N,hash,m);
	v512[63] = len & 0xFF;
	v512[62] = len >> 8;
	AddModulo512(N,v512,N);

	AddModulo512(Sigma,m,Sigma);

	g_N(v0,hash,N);
	g_N(v0,hash,Sigma);

	memcpy(out, hash, 64);
}
#if 0
void hash_512(const unsigned char *message,unsigned long long length,unsigned char *out)
{
	unsigned char IV[64] =
	{
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};

	hash_X(IV,message,length,out);
}

void hash_256(const unsigned char *message,unsigned long long length,unsigned char *out)
{
	unsigned char IV[64] =
	{
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01
	};
	unsigned char hash[64];

	hash_X(IV,message,length,hash);

	memcpy(out,hash,32);
}
#endif
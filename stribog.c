/*
 * stribog.c
 *
 *  Created on: May 5, 2012
 *      Author: Oleksandr Kazymyrov
 *		Acknowledgments: Oleksii Shevchuk
 */
 
#if 0
// \see https://www.hse.ru/data/2013/08/01/1291252307/lebedev-hashes.pdf
const  uint8_t  pi[256] = {
/* pi  constant  */
};
const  uint64_t A[64] = {
/* A constant  */
};
uint64_t  mul_table [8][256];
void  precalc_mul_table ()
{
for(int i=0;i<8;++i)
for(int j=0;j <256;++j){
uint64_t t = 0;
uint8_t p = pi[j];
for(int k=0;k<8;++k)
if(p&(1<<k))
t ^= A[(i<<3)|k];
mul_table[i][j] = t;
}
}
void  lps(uint64_t* out ,const  uint8_t* in)
{
for(int i=0;i<8;++i){
uint64_t t = mul_table [0][in[i]];
for(int k=1;k<8;++k)
t ^=  mul_table[k][in[i+k*8]];
out[i] = t;
}
}

#endif

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <math.h>

#include "stribog_data.h"
#pragma GCC optimize("Os")
static void AddModulo512(const unsigned char *a,const unsigned char *b,unsigned char *c)
{
	int i = 0, t = 0;

	for(i=63;i>=0;i--)
	{
		t = a[i] + b[i] + (t >> 8);
		c[i] = t & 0xFF;
	}
}

static void AddXor512(const void *a,const void *b,void *c)
{
	int i = 0;
	const uint32_t *A=a, *B=b;
	uint32_t *C=c;

	for(i=0;i<16;i++)
	{
		C[i] = A[i] ^ B[i];
	}
}

static void S(unsigned char *state)
{
	int i = 0;

	for(i=0;i<64;i++)
	{
		state[i] = Sbox[state[i]];
	}
}
/* Преобразование L можно представить матричным умножением в поле 0x171

Algebraic Aspects of the Russian Hash Standard GOST R 34.11-2012
Oleksandr Kazymyrov, Valentyna Kazymyrova

M = {
71 05 09 B9 61 A2 27 0E
04 88 5B B2 E4 36 5F 65
5F CB AD 0F BA 2C 04 A5
E5 01 54 BA 0F 11 2A 76
D4 81 1C FA 39 5E 15 24
05 71 5E 66 17 1C D0 02
2D F1 E7 28 55 A0 4C 9A
0E 02 F6 8A 15 9D 39 71
};
L = B*A
Пояснение, как оно соотносится с с матрицей A
Колонка 1 матрицы M - это элемент A[0], для которого выполнен разворот порядка следования бит. 
8E=>71 20=>04 FA=>5F
Колонка 2 матрицы M - это элемент A[8],
. . .
Колонка 8 матрицы M - это элемент A[56],

От транспонивания вероятно можно избавиться
Умножение можно выполнить на аффинных преобразованиях или на умножении без переноса с редуцированием

На Neon есть умножение без переноса (Polynomial) 8x8 => 16*8
*/

static void L(unsigned char *state)
{
	unsigned long long v = 0;
	int i = 0, j = 0, k = 0;

	for(i=0;i<8;i++)
	{
		v=0;
		for(k=0;k<8;k++)
		{// умножение s_k,i = sum_k MA_i,k*s_k,i
			for(j=0;j<8;j++)
			{
				if ((state[i*8+k] & (1<<(7-j))) != 0)
					v ^= A[k*8+j];// v = REV8(K[i*8+k] (*) REV8(state[n]) mod 0x171)
			}
		}
		for(k=0;k<8;k++)
		{
			state[i*8+k] = (v & ((unsigned long long)0xFF << (7-k)*8)) >> (7-k)*8;
		}
	}
}
static void P(unsigned char *state)
{
	int i = 0;
	unsigned char t[64] = {};

	for(i=0;i<64;i++)
	{
		t[i] = state[Tau[i]];
	}

	memcpy(state,t,64);
}

uint8_t LM[] = {
0x71, 0x05, 0x09, 0xB9, 0x61, 0xA2, 0x27, 0x0E,
0x04, 0x88, 0x5B, 0xB2, 0xE4, 0x36, 0x5F, 0x65,
0x5F, 0xCB, 0xAD, 0x0F, 0xBA, 0x2C, 0x04, 0xA5,
0xE5, 0x01, 0x54, 0xBA, 0x0F, 0x11, 0x2A, 0x76,
0xD4, 0x81, 0x1C, 0xFA, 0x39, 0x5E, 0x15, 0x24,
0x05, 0x71, 0x5E, 0x66, 0x17, 0x1C, 0xD0, 0x02,
0x2D, 0xF1, 0xE7, 0x28, 0x55, 0xA0, 0x4C, 0x9A,
0x0E, 0x02, 0xF6, 0x8A, 0x15, 0x9D, 0x39, 0x71,
};
// экспонента для табличного умножения и инверсии
static const uint8_t exp_171[256] = {// экспонента Poly 0x171 Rev8 по выходу
	0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x8E, 0x47, 0xAD, 0xD8, 0x6C, 0x36, 0x1B, 0x83,
	0xCF, 0xE9, 0xFA, 0x7D, 0xB0, 0x58, 0x2C, 0x16, 0x0B, 0x8B, 0xCB, 0xEB, 0xFB, 0xF3, 0xF7, 0xF5,
	0xF4, 0x7A, 0x3D, 0x90, 0x48, 0x24, 0x12, 0x09, 0x8A, 0x45, 0xAC, 0x56, 0x2B, 0x9B, 0xC3, 0xEF,
	0xF9, 0xF2, 0x79, 0xB2, 0x59, 0xA2, 0x51, 0xA6, 0x53, 0xA7, 0xDD, 0xE0, 0x70, 0x38, 0x1C, 0x0E,
	0x07, 0x8D, 0xC8, 0x64, 0x32, 0x19, 0x82, 0x41, 0xAE, 0x57, 0xA5, 0xDC, 0x6E, 0x37, 0x95, 0xC4,
	0x62, 0x31, 0x96, 0x4B, 0xAB, 0xDB, 0xE3, 0xFF, 0xF1, 0xF6, 0x7B, 0xB3, 0xD7, 0xE5, 0xFC, 0x7E,
	0x3F, 0x91, 0xC6, 0x63, 0xBF, 0xD1, 0xE6, 0x73, 0xB7, 0xD5, 0xE4, 0x72, 0x39, 0x92, 0x49, 0xAA,
	0x55, 0xA4, 0x52, 0x29, 0x9A, 0x4D, 0xA8, 0x54, 0x2A, 0x15, 0x84, 0x42, 0x21, 0x9E, 0x4F, 0xA9,
	0xDA, 0x6D, 0xB8, 0x5C, 0x2E, 0x17, 0x85, 0xCC, 0x66, 0x33, 0x97, 0xC5, 0xEC, 0x76, 0x3B, 0x93,
	0xC7, 0xED, 0xF8, 0x7C, 0x3E, 0x1F, 0x81, 0xCE, 0x67, 0xBD, 0xD0, 0x68, 0x34, 0x1A, 0x0D, 0x88,
	0x44, 0x22, 0x11, 0x86, 0x43, 0xAF, 0xD9, 0xE2, 0x71, 0xB6, 0x5B, 0xA3, 0xDF, 0xE1, 0xFE, 0x7F,
	0xB1, 0xD6, 0x6B, 0xBB, 0xD3, 0xE7, 0xFD, 0xF0, 0x78, 0x3C, 0x1E, 0x0F, 0x89, 0xCA, 0x65, 0xBC,
	0x5E, 0x2F, 0x99, 0xC2, 0x61, 0xBE, 0x5F, 0xA1, 0xDE, 0x6F, 0xB9, 0xD2, 0x69, 0xBA, 0x5D, 0xA0,
	0x50, 0x28, 0x14, 0x0A, 0x05, 0x8C, 0x46, 0x23, 0x9F, 0xC1, 0xEE, 0x77, 0xB5, 0xD4, 0x6A, 0x35,
	0x94, 0x4A, 0x25, 0x9C, 0x4E, 0x27, 0x9D, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x8F, 0xC9,
	0xEA, 0x75, 0xB4, 0x5A, 0x2D, 0x98, 0x4C, 0x26, 0x13, 0x87, 0xCD, 0xE8, 0x74, 0x3A, 0x1D, 0x80,
};
static const uint8_t log_LM[64] = {// логарифм
	0x08, 0xCF, 0x23, 0xE6, 0xA3, 0x29, 0x6A, 0x3C,
	0x02, 0xA2, 0x80, 0x75, 0xE5, 0x0C, 0x12, 0x37,
	0x12, 0xB4, 0xDC, 0xB7, 0xCE, 0x9C, 0x02, 0x4A,
	0x39, 0x00, 0x78, 0xCE, 0xB7, 0x9F, 0x77, 0x4C,
	0x2C, 0x96, 0x3D, 0xC6, 0xE3, 0x21, 0x76, 0x25,
	0xCF, 0x08, 0x21, 0x88, 0xFB, 0x3D, 0x18, 0x01,
	0xF2, 0xEE, 0xB5, 0xD2, 0x6F, 0xD4, 0x44, 0x34,
	0x3C, 0x01, 0xC9, 0x36, 0x76, 0xCA, 0xE3, 0x08,
};

// Матрица линейных преобразований 
static const uint8_t LM_11b[8*8]={
	0xF6,0x55,0x74,0xE4,0x56,0x3E,0xC1,0x2F,
	0x54,0xDF,0x17,0x9E,0xA9,0x60,0x43,0x02,
	0x43,0x1D,0x10,0x2E,0xEB,0xBB,0x54,0x65,
	0xA8,0x01,0x39,0xEB,0x2E,0xA1,0xE1,0xAD,
	0x93,0xAB,0x81,0x26,0x4E,0x42,0xF5,0xCE,
	0x55,0xF6,0x42,0x0D,0xFB,0x81,0xC7,0x0E,
	0xBA,0x5C,0xA6,0xEF,0x38,0x30,0xEC,0x71,
	0x2F,0x0E,0x07,0xD1,0xF5,0x2A,0x4E,0xF6,
};
static const uint64_t R = 0x8040201008040201;
static unsigned char Sbox_R[256] = {// S-Box Stribog 0x171 Rev8
0x3F,0xFB,0xD7,0xE0,0x9F,0xE5,0xA8,0x04,0x97,0x07,0xAD,0x87,0xA0,0xB5,0x4C,0x9A,
0xDF,0xEB,0x4F,0x0C,0x81,0x58,0xCF,0xD3,0xE8,0x3B,0xFD,0xB1,0x60,0x31,0xB6,0x8B,
0xF3,0x7C,0x57,0x61,0x47,0x78,0x08,0xB4,0xC9,0x5E,0x10,0x32,0xC7,0xE4,0xFF,0x67,
0xC4,0x3E,0xBF,0x11,0xD1,0x26,0xB9,0x7D,0x28,0x72,0x39,0x53,0xFE,0x96,0xC3,0x9C,
0xBB,0x24,0x34,0xCD,0xA6,0x06,0x69,0xE6,0x0F,0x37,0x70,0xC1,0x40,0x62,0x98,0x2E,
0x5F,0x6B,0x16,0xD6,0x3C,0x1C,0x1E,0xA4,0x8F,0x14,0xC8,0x55,0xB7,0xA5,0x63,0xF5,
0x8C,0xC2,0x12,0xB8,0xF7,0x46,0x59,0x90,0x99,0x0D,0x6E,0x1F,0xF1,0xAA,0x51,0x2D,
0x20,0x9D,0x73,0xE7,0x71,0x64,0x4D,0x36,0xFA,0x50,0xBA,0xA1,0xCB,0xA9,0xB0,0xC6,
0x77,0xAF,0x2C,0x1A,0x18,0xE9,0x85,0x8E,0xEE,0xF0,0x0E,0xD8,0x21,0xA2,0xAE,0x65,
0x23,0x9E,0x54,0xEC,0x38,0x1D,0x89,0xD9,0x6C,0x17,0x4E,0xCA,0xD0,0xC5,0x2A,0x66,
0x76,0x15,0x13,0x35,0x3A,0x00,0xDE,0xD4,0x74,0x29,0x30,0xFC,0x56,0x7A,0xAC,0x2F,
0xA3,0x44,0x5C,0x9B,0x80,0xF9,0x79,0xA7,0xB3,0xCC,0xED,0x1B,0x2B,0xAB,0xBD,0xD2,
0x88,0x95,0x8A,0x02,0x5A,0xCE,0x94,0x25,0xDB,0x7B,0x6A,0x92,0x75,0x49,0xBC,0x4B,
0x5B,0x6F,0x45,0x27,0x42,0x41,0xF6,0x0B,0xDD,0x0A,0xE2,0x09,0x19,0xBE,0x01,0x43,
0x68,0x93,0xD5,0xEF,0x84,0x22,0xE3,0xDA,0x5D,0x3D,0x48,0x7F,0x05,0xF4,0x7E,0x03,
0xB2,0xC0,0x33,0x91,0xF2,0x82,0x8D,0x4A,0x83,0x52,0xE1,0x86,0xF8,0xDC,0xEA,0x6D,
};
static const uint8_t log_Sbox[256] = {// 0x00, 0xFF Rev8 по входу
	0x5E, 0xDA, 0x3A, 0xA2, 0x10, 0x4C, 0x51, 0x17, 0x1C, 0x4F, 0x12, 0x80, 0xD7, 0x8B, 0x05, 0x75,
	0x11, 0xDB, 0xB7, 0x55, 0x8F, 0x84, 0xC2, 0xCD, 0x85, 0x0D, 0x58, 0xB3, 0xD2, 0xFA, 0xC6, 0xD9,
	0x30, 0xEA, 0xBE, 0xF3, 0xA7, 0x83, 0x2F, 0x7C, 0x96, 0x3E, 0xB9, 0x7B, 0x19, 0x07, 0x08, 0x7E,
	0xD4, 0x7A, 0x06, 0x48, 0x56, 0xDE, 0xEE, 0xCF, 0xEC, 0x18, 0x91, 0xF5, 0xAF, 0xDD, 0xB4, 0x95,
	0x1B, 0x9C, 0x16, 0x36, 0xF0, 0x42, 0x24, 0x54, 0x31, 0x78, 0x9B, 0x35, 0xB6, 0xFD, 0x97, 0x87,
	0xDC, 0x3C, 0x3F, 0x2B, 0x04, 0xEB, 0x8D, 0x26, 0x64, 0x6B, 0xF8, 0x09, 0xE3, 0x68, 0xCE, 0xF9,
	0x79, 0xC7, 0x52, 0x73, 0x03, 0x5A, 0x74, 0x90, 0x1D, 0x61, 0xB8, 0xC9, 0xE6, 0x7D, 0x33, 0xB0,
	0x44, 0xF1, 0x45, 0x22, 0x57, 0xDF, 0x28, 0x5F, 0x81, 0x77, 0x62, 0x00, 0x2E, 0x99, 0x9E, 0x49,
	0xAC, 0x1F, 0x25, 0x7F, 0x94, 0x76, 0xA4, 0xEF, 0x5C, 0x32, 0xB1, 0x59, 0x93, 0xA1, 0xCA, 0xED,
	0x3B, 0xBB, 0x8C, 0xC8, 0x21, 0xE0, 0x14, 0xBF, 0x4B, 0xFB, 0xD1, 0xD0, 0xE4, 0x89, 0xD3, 0xE1,
	0x39, 0x8A, 0xE8, 0x67, 0xBA, 0xFF, 0x50, 0xA0, 0x9D, 0x82, 0x3D, 0x46, 0x43, 0xD8, 0xF7, 0x47,
	0x0A, 0x29, 0xD6, 0x6D, 0xE5, 0xC0, 0x70, 0xC1, 0xD5, 0xAB, 0x4A, 0x13, 0xCC, 0x69, 0x4E, 0x8E,
	0x40, 0x15, 0x5B, 0x01, 0xA3, 0x2A, 0xFE, 0x1E, 0xE9, 0x4D, 0xB2, 0x6A, 0x9F, 0xA6, 0xB5, 0xBC,
	0xAD, 0x0E, 0x0F, 0x6E, 0xF6, 0x60, 0x92, 0xAE, 0x41, 0x38, 0x6F, 0x23, 0xBD, 0x0B, 0x86, 0xC4,
	0x02, 0xA8, 0x98, 0x71, 0xF4, 0x2C, 0x27, 0xAA, 0x1A, 0x2D, 0xE2, 0x9A, 0xC5, 0x5D, 0x0C, 0x72,
	0x34, 0x37, 0xFC, 0xCB, 0x66, 0x20, 0xF2, 0xE7, 0x65, 0x88, 0xA5, 0xC3, 0x6C, 0x53, 0x63, 0xA9,
};

uint32_t cl_mul8(uint32_t p, uint32_t i){
	uint32_t r=0;
	while (i) {
		if (i&1)r^=p;
		p<<=1;
		i>>=1;
	}
	return r;
}
uint32_t gf2p8_mul(uint32_t p, uint32_t i, uint32_t Poly){
	uint32_t r=0;
	while (i) {
		if (i&1)r^=p;
		if (p&0x80){
			p=(p<<1) ^ Poly;
		} else
			p=(p<<1);
		i>>=1;
	}
	return r;
}
uint8_t Rev8(uint8_t a){
	const uint8_t m4=0x0F, m2=0x33, m1=0x55;
	a = (a &~m4)>>4 | (a & m4)<<4;
	a = (a &~m2)>>2 | (a & m2)<<2;
	a = (a &~m1)>>1 | (a & m1)<<1;
	return a;
}
void MulM(const uint8_t* s, uint8_t* r)
{
	int i,j,k;
	for (i=0; i<8; i++)
	for (j=0; j<8; j++) {
		uint8_t v= 0;
		for (k=0; k<8; k++) 
			v ^= gf2p8_mul(LM[j*8+k], Sbox_R[Rev8(s[k*8+i])], 0x171);
		r[i*8+j] = Rev8(v);
	}
}
static inline uint8_t mod255(unsigned v){
	return v + (v>>8);
}
// табличное умножение через логарифм
void MulME(const uint8_t* s, uint8_t* r)
{
	int i,j,k;
	for (i=0; i<8; i++)
	for (j=0; j<8; j++) {
		uint8_t v= 0;
		for (k=0; k<8; k++) {
			uint8_t a5 = s[k*8+i];
			if (a5!=0xA5)// магия чтобы избежать деления на ноль
				v ^= exp_171[mod255(log_LM[j*8+k] + log_Sbox[(a5)])];
		}
		r[i*8+j] = (v);
	}
}
/*! Выделяет строку матрицы */
static inline uint8_t m_row(uint64_t qword, int n){
	return qword>>(8*(7-n));
}
/*! \brief аффинные преобразования по матрице 8x8 
	\param qword - матрица 
	\param byte - вектор из 8 бит.
	\return произведение матрицы на вектор y=A*x.
 */
uint8_t affine(uint64_t qword, uint8_t byte) {
    uint8_t res = 0;
	int i;
    for (i=0; i < 8; i++) {
        uint8_t x = m_row(qword,i) & byte;
        //uint8_t x = (qword>>((7-i)*8)) & byte;
        res |= __builtin_parity(x)<<i;
    }
//	printf("%02X => %02X\t%016llX\n", byte,res, qword);
    return res;
}
/*! Выделяет колонку матрицы */
uint8_t m_column(uint64_t qword, int n)
{
	uint8_t r=0;
	uint8_t mask = 1<<n;
	int i;
	for (i=0;i<8;i++)
		if((qword>>(8*(7-i))) & mask) 
			r |= (1<<i);
	return r;
}

/*! \brief Перемножение матриц аффинного преобразования 8x8

	Более эффективный способ перемножения с использованием инструкции gf2p8affine
	\param m1 матрица m1
	\param m2 матрица m2
	\return m1*m2 - произведение матриц.
 */
uint64_t m_mul(uint64_t m1, uint64_t m2)
{
	uint64_t r=0;
	int x,y;
	for (y=0;y<8;y++)
	for (x=0;x<8;x++)
		r |= (uint64_t)__builtin_parity(m_row(m1, y) & m_column(m2, x)) << ((7-y)*8+x);
	return r;
}
/*! \brief Транспонирование матрицы

	Более Эффективный способ транспонирования с использованием инструкции gf2p8affine
	\param m - матрица аффинных преобразовани 8x8.
 */
uint64_t m_transpose(uint64_t m)
{
	uint64_t r = 0;
	int x,y;
	for (y=0; y<8; y++){
		uint8_t row = m>>(8*(7-y));
		for (x=0; x<8; x++){
			if(row & (1<<x))
				r |= 1ULL<< ((7-x)*8+y);
		}
	}
	return r;
}

/* матрица умножения на константу */
uint64_t m_mulC(uint8_t c, uint32_t Poly){
	uint64_t m = c;
	int i;
	for (i=1;i<8;i++){
		uint8_t v = gf2p8_mul(c, 1<<i, Poly);
		m = (m<<8) ^ v;
	}
	return m_transpose(m);
}

uint64_t Q_171 = 0x8D1A34685D37E3C6;
void MulMQ(const uint8_t* s, uint8_t* r)
{
	int i,j,k;
	for (i=0; i<8; i++)
	for (j=0; j<8; j++) {
		uint16_t v= 0;
		for (k=0; k<8; k++) 
			v ^= cl_mul8(LM[j*8+k], Sbox_R[Rev8(s[k*8+i])]);
		r[i*8+j] = Rev8((v & 0xFF) ^ affine(Q_171,v>>8));
	}
}
/* Ux 0x163 Px 171
// Редуцирование 16 бит в 8 бит
	t  = vmull_p8(vshrnq_n_u16(q,8), Ux) ^ q;
	q ^= vmull_p8(vshrnq_n_u16(t,8), Px);// младшая часть
	
    /// редуцирование вынесли из цикла
    poly8x8_t t0;
	poly16x8_t t;
	const poly8x8_t Ux = vdup_n_p8(0x63);
	const poly8x8_t Px = vdup_n_p8(0x71);
    t0 = (poly8x8_t) vshrn_n_u16((uint16x8_t)v, 8);
    t  = vmull_p8(t0, Ux);
    t0^= (poly8x8_t) vshrn_n_u16((uint16x8_t)t, 8);// сдвиг вправо с заужением
    v ^= vmull_p8(t0, Px);

*/
static uint8_t Sbox_iso[256] = {//S-Box Stribog 0x171 [0x11B]=

0x14,0x27,0x97,0x06,0x39,0xDC,0xB6,0x8A,0xA4,0x53,0x95,0x25,0x0A,0x19,0x9C,0xFD,
0x8C,0x37,0xBD,0x8D,0x2B,0x68,0x12,0x38,0x84,0xF4,0x50,0x72,0x2C,0x04,0xB4,0x11,
0xC5,0x30,0x7E,0x20,0x0D,0xE1,0xFC,0xF0,0xA5,0x63,0x32,0xC7,0x78,0x8E,0x71,0xEC,
0xAD,0xF5,0x48,0x16,0xBE,0xA1,0x64,0x8F,0x81,0x1B,0x33,0x15,0xCF,0x5E,0xAF,0x6F,
0x62,0x4E,0x58,0x08,0xEE,0xA3,0xA2,0xB9,0xB1,0xB7,0x7C,0x3A,0xCB,0x65,0xF9,0xEF,
0xDE,0xB3,0x0B,0x35,0x24,0xA8,0x69,0x8B,0xE5,0xAE,0x45,0x54,0x67,0x9E,0x4F,0x80,
0xE4,0xD7,0x9D,0xFA,0x41,0x00,0x5F,0xDF,0x0E,0xD1,0xE8,0x93,0x2D,0x43,0xC6,0xC0,
0x1C,0xE2,0x86,0x77,0x5B,0x51,0x5C,0x4B,0x6C,0xBA,0xF1,0x10,0x28,0xE6,0xFB,0x76,
0x3B,0x57,0x26,0x6D,0x02,0x1F,0xB8,0xD9,0x4D,0x1A,0x3E,0x9B,0xEB,0x31,0xD0,0xCA,
0x3F,0x99,0xCC,0xC3,0x36,0x56,0xA7,0x23,0x5A,0x6A,0x52,0xD6,0x7A,0x07,0x4C,0x70,
0xE9,0x87,0x03,0xF6,0xBB,0xDB,0xBC,0xF2,0x94,0xFE,0xAC,0x1E,0x60,0xED,0xE3,0x21,
0x4A,0xE0,0xE7,0x7B,0x0C,0x73,0xF7,0x66,0x2E,0x61,0xA9,0x3C,0xF3,0x74,0xC9,0xB0,
0x75,0xC4,0x47,0x6E,0xAA,0x29,0x79,0x17,0xC1,0x98,0x83,0x6B,0xCE,0xEA,0x96,0x82,
0xB2,0x2F,0xD8,0x0F,0x40,0x88,0x1D,0x44,0x90,0x3D,0x91,0x7D,0x55,0x09,0x5D,0xD2,
0x34,0xA0,0x7F,0xB5,0x46,0x9F,0xD4,0xBF,0x01,0xC2,0xDA,0xDD,0xCD,0x59,0x42,0x13,
0xFF,0x85,0xD3,0x92,0xAB,0x18,0x2A,0x9A,0xA6,0xF8,0x49,0xC8,0x05,0x22,0xD5,0x89,
};
void MulM_11b(const uint8_t* s, uint8_t* r)
{
	const uint64_t mr= 0x924572473419320F, rm_=0x1C0A5ACCF0BA44FB;

	int i,j,k;
	for (i=0; i<8; i++)
	for (j=0; j<8; j++) {
		uint8_t v= 0;
		for (k=0; k<8; k++) // можно транспонировать LM_11b и перейти к вектору по j за раз делать две строки
			v ^= gf2p8_mul(LM_11b[j*8+k], Sbox_iso[affine(/* m_mul(m,R) */mr,(s[k*8+i]))], 0x11b);
		r[i*8+j] = (affine(/* m_mul(R,m_) */rm_,v));
	}
}
#if 0
void MulMT_11b(const uint8_t* s, uint8x8_t* r)
{
	const uint64_t mr= 0x924572473419320F, rm_=0x1C0A5ACCF0BA44FB;

	int i,k;
	for (i=0; i<8; i++){
		uint8x16_t v={0};
		for (k=0; k<8; k++){ // можно транспонировать LM_11b и перейти к вектору по j за раз делать две строки
			a8 = vdup_n_p8(Sbox_iso[affine(mr, s[k*8+i])]);
			v ^= vmull_p8(LMT_11b[k], a8, 0x11b);
		}
		// выполнить редуцирование или два аффинных преобразования от старшей и младшей части
		r[i] = affine8(/* m_mul(R,m_) */rm_,v);
	}
}
#endif

/*! \brief вывод на экран матрицы 8x8 */
void m_print(uint64_t m)
{
	int x,y;
	for (y=0; y<8; y++){
		uint8_t row = m>>(8*(y));
		for (x=0; x<8; x++){
			printf("%c",(row & (1<<(7-x)))?'1':'0');
		}
		printf(" %02X\n", row);
	}
}

void printM(const char* str, const uint8_t* s){
	int i,j;
	puts(str);
	for (i=0;i<8; i++) {
		for (j=0;j<8; j++) {
			printf("%02X ", s[i*8+j]);
		}
		puts("");
	}
}
int main ()
{
/*

nsigned char p(unsigned char x){
    unsigned char
        s[]={1,221,146,79,147,153,11,68,214,215,78,220,152,10,69},
        k[]={0,32,50,6,20,4,22,34,48,16,2,54,36,52,38,18,0};    
    if(x) {
        unsigned char l=1, a=2;
        while(a!=x) {
            a=(a<<1)^(a>>7)*29;
            l++;
        }
        if (l%17) return 252^k[l%17]^s[l/17];
        else return 252^k[l/17];
    }
    else return 252;
}

матрица для 171 => 11B "Stribog"
171=>11B 02 0E M =49A24EE22C984CF0 M-1 =FB44BAF0CC5A0A1C
171=>11B 02 17 M =C30E560C5240D828 M-1 =6D0A141C3A9C2046
171=>11B 02 52 M =B1A27CD0765CD234 M-1 =F5481A5CBE24D86E
171=>11B 02 54 M =29903A0892D47ABC M-1 =E5126608F2EC44F0
171=>11B 02 A0 M =C154448014AEDCC6 M-1 =1B8C164A06F81208
171=>11B 02 B4 M =1590FECC3E8E8CE6 M-1 =9960C6DA5E32485C
171=>11B 02 F6 M =090EFAA096722E1A M-1 =6FD8B46E36428C4A
171=>11B 02 FD M =A7541EDA2602426A M-1 =CB20B646D48660DA
*/
	const uint64_t m = 0x49A24EE22C984CF0, m_ =0xFB44BAF0CC5A0A1C;
	uint64_t mr, rm_;
	int i,j;
#if 0	
	printf("S-Box Stribog 0x171 [0x11B]=\n"); 
	mr  = m_mul(m, R );
	rm_ = m_mul(R, m_);
	for (i=0;i<256; i++) {
		Sbox_iso[i] = affine(mr, Sbox[affine(rm_,i)]);
		if ((i&0xF)==0)printf("\n");
		printf("0x%02X,", Sbox_iso[i]);
	}
	printf("\n");	
#endif	
#if 1	
	uint32_t poly = 0x171;
	Q_171 = m_mulC(poly&0xFF, poly);
	printf("Q[0x171] = %016llX\n", Q_171);
	printf("S-Box Stribog 0x171 Rev8 =\n"); 
	for (i=0;i<256; i++) {
		Sbox_R[i] = affine(R, Sbox[affine(R,i)]);
		if ((i&0xF)==0)printf("\n");
		printf("0x%02X,", Sbox_R[i]);
	}
	printf("\n");	
#endif	
	uint8_t s[64], r[64], ra[64], rq[64], re[64];
	for (i=0;i<64; i++) s[i] = i;
	//s[8]=73;
	printM("Matrix S", s);
	MulM(s,r);
	MulM_11b(s,ra);
	MulMQ(s,rq);
	MulME(s,re);
	S(s);
	P(s);
	L(s);
	printM("Matrix LPS", s);
	printM("Matrix MS", r);
	printM("Matrix MAS", ra);
	printM("Matrix MQS", rq);
	printM("Matrix ME", re);

	m_print(mr = m_mul(m, R ));
	printf("%016llX\n", mr);
	m_print(mr = m_mul(R, m_));
	printf("%016llX\n", mr);
	return 0;
}
static void F1(uint8_t* v, uint8_t* w)
{
	//MulME(s, )
}
static void KeySchedule(unsigned char *K,int i)
{
	AddXor512(K,C[i],K);

    S(K);// подстановка
    P(K);// транспонирование
    L(K);// линейная операция
}

static void E(unsigned char *K,const unsigned char *m, unsigned char *state)
{
	int i = 0;

	memcpy(K,K,64);

	AddXor512(m,K,state);

    for(i=0;i<12;i++)
    {
		AddXor512(K,C[i],K);

		S(K);// подстановка
		P(K);// транспонирование
		L(K);// линейная операция
		
        S(state);// подстановка
        P(state);// транспонирование
        L(state);
//        KeySchedule(K,i);
        AddXor512(state,K,state);
    }
}

static void g_N(const unsigned char *N,unsigned char *h,const unsigned char *m)
{
	unsigned char t[64], K[64];

	AddXor512(N,h,K);

    S(K);
    P(K);// транспонирование
    L(K);// линейная операция

    E(K,m,t);

    AddXor512(t,h,t);
    AddXor512(t,m,h);
}
void hash_X(unsigned char *IV,const unsigned char *message,unsigned long long length,unsigned char *out)
{
	unsigned char v512[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00
	};
	unsigned char v0[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};
	unsigned char Sigma[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};
	unsigned char N[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};
	unsigned char m[64], *hash = IV;
	unsigned long long len = length;

	// Stage 2
	while (len >= 512)
	{
		memcpy(m, message + len/8 - 63 - ( (len & 0x7) == 0 ), 64);

		g_N(N,hash,m);
		AddModulo512(N,v512,N);
		AddModulo512(Sigma,m,Sigma);
		len -= 512;
	}

	memset(m,0,64);
	memcpy(m + 63 - len/8 + ( (len & 0x7) == 0 ), message, len/8 + 1 - ( (len & 0x7) == 0 ));

	// Stage 3
	m[ 63 - len/8 ] |= (1 << (len & 0x7));

	g_N(N,hash,m);
	v512[63] = len & 0xFF;
	v512[62] = len >> 8;
	AddModulo512(N,v512,N);

	AddModulo512(Sigma,m,Sigma);

	g_N(v0,hash,N);
	g_N(v0,hash,Sigma);

	memcpy(out, hash, 64);
}
#if 0
void hash_512(const unsigned char *message,unsigned long long length,unsigned char *out)
{
	unsigned char IV[64] =
	{
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};

	hash_X(IV,message,length,out);
}

void hash_256(const unsigned char *message,unsigned long long length,unsigned char *out)
{
	unsigned char IV[64] =
	{
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01
	};
	unsigned char hash[64];

	hash_X(IV,message,length,hash);

	memcpy(out,hash,32);
}
#endif